<?php
/**
 * Created by IntelliJ IDEA.
 * User: r_a
 * Date: 6/27/2019
 * Time: 11:07 PM
 */

namespace Schedule\Modules\Authority\Forms;


use Phalcon\Forms\Element\Check;
use Phalcon\Forms\Element\Hidden;
use Phalcon\Forms\Element\Select;
use Phalcon\Forms\Element\Text;
use Phalcon\Forms\Form;
use Schedule\Core\Components\DataText;
use Schedule\Core\Components\Time;
use Schedule\Core\Models\Company;
use Schedule\Modules\Authority\Models\Route;

class RouteForm extends Form
{
	public function initialize(Route $input_route, $options)
	{
		$this->setEntity($input_route);

		 $id = new Hidden('id');

		 $start_st =new DataText('start_st',['class'=>'city from']);
		 $start_st->setLabel("Початкова станція")->setUserOption('common','true');
		 $end_st = new DataText('end_st',['class'=>'city to']);
		 $end_st->setLabel("Кінцева станція")->setUserOption('common','true');
		 $made_by = new Select('made_by',Company::find(),[
		 	'using' => [
		 		'id',
			    'name'
		    ],
		    'emptyText' => "Будь-ласка оберіть компанію",
		    'useEmpty'=>true,
		    'emptyValue'=>''
		 ]);
		 $made_by->setUserOption('common','true')->setLabel("Компанію, що здійснює перевезення");
		 $this->add($start_st)->add($end_st)->add($made_by)->add($id);
		$this->addRegularity();
		$this->addTransit($options['stations']??0);

	}

	private function addRegularity()
	{
		$regularity = new Check('demo',['autocomplete'=>'off']);
		$regularity->setUserOption('regularity','true');
		$timestamp = strtotime('next Monday');
		for($i = 1; $i<=7;$i++){
			$thie_element= clone $regularity;
			$thie_element->setLabel(strftime('%A',$timestamp));
			$thie_element->setName("regularity[$i]");
			$this->add($thie_element);
			$timestamp=strtotime('+1 day',$timestamp);
		}
	}

	private function addTransit($stations)
	{
		$start_st =new DataText('start_st',['class'=>'city from']);
		$start_st->setLabel("Початкова станція");
		$end_st = new DataText('end_st',['class'=>'city to']);
		$end_st->setLabel("Кінцева станція");

		$start_time=new Time('start_time');
		$start_time->setUserOption('transit','true');
		$end_time=(clone $start_time)->setName('end_time');
		$start_st->setUserOption('transit','true');
		$end_st->setUserOption('transit','true');
		for ($i=0; ;$i++){
			$start_st_ent= clone $start_st;
			$start_st_ent->setName(
				$start_st_ent->getName().$i
			);
			$start_time_ent =clone  $start_time;
			$start_time_ent->setName(
				$start_time_ent->getName().$i
			);
			$end_st_ent= clone $end_st;
			$end_st_ent->setName(
				$end_st_ent->getName().$i
			);
			$end_time_ent =clone  $end_time;
			$end_time_ent->setName(
				$end_time_ent->getName().$i
			);
			$this->add($start_st_ent)->add($start_time_ent)->add($end_st_ent)->add($end_time_ent);

			if(($stations-1)<=$i || $stations==0) break;
		}


	}

	/**
	 * Binds data to the entity
	 *
	 * @param  array  $data
	 * @param  object  $entity
	 * @param  array  $whitelist
	 *
	 * @return Form
	 */
	public function bind(array $data , $entity , $whitelist = null)
	{
		parent::bind($data, $entity,
			$whitelist);
		$transit_data=array_filter($data, ['this','filter'],ARRAY_FILTER_USE_BOTH);
		$entity->path = $transit_data;
		return $this;
	}

	/**
	 * Gets a value from the internal related entity or from the default value
	 *
	 * @param string $name
	 *
	 * @return mixed|null
	 */
	public function getValue($name)
	{
		// TODO: Change the autogenerated stub
		if(	$this->getIndex($name,['from'=>'start_st','to'=>'end_st'],$match)){
			$var_path=$this->_entity->getPath();
			if (key_exists($match->index,$var_path)){
				return
					$var_path[$match->index][$match->direction];
			}
		}
		if(	$this->getIndex($name,['from_time'=>'start_time','to_time'=>'end_time'],$match)){
			$var_path=$this->_entity->getPath();
			if (key_exists($match->index,$var_path)){
				return
					$var_path[$match->index][$match->direction];
			}
		}
		elseif( strpos($name,'regularity')!==false ){
			preg_match('/regularity\[([1-7])\]/',$name,$match);
			if( !empty($match[1])){
				return ($this->_entity->getRegularity()[$match[1]]??false);
			}
		}
		else{
			return parent::getValue($name);
		}
	}
	private function getIndex( string $name_of_fields, array $fields, &$index){

		foreach ($fields as $key => $pattern){
			 if ( strpos($name_of_fields,$pattern)!==false && strcmp($pattern,$name_of_fields) < 0){
			 	$index=(object)[
			 		"index"=>substr($name_of_fields,strlen($pattern)),
					"direction" =>$key
						];
			 	return true;
			 }
		}
		return false;

	}


	private function filter($key, $value)
	{
		var_dump($key,$value);
	}
}